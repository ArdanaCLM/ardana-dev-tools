# The MIT License
#
# Copyright (c) 2010-2015 Mitchell Hashimoto
# (c) Copyright 2015-2017 Hewlett Packard Enterprise Development LP
# (c) Copyright 2017 SUSE LLC
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
require 'vagrant/util/retryable'
require 'vagrant/machine'

# following are required to load the classes in order to monkey patch them
require Vagrant.source_root.join('plugins/provisioners/ansible/config').to_s
require Vagrant.source_root.join('plugins/provisioners/ansible/provisioner').to_s

module Vagrant
  class Machine

    alias_method :old_initialize, :initialize
    def initialize(*args)
      @state_mutex = Mutex.new
      old_initialize(*args)
    end

    # state uses 'machine_index.get(uuid)' which returns a locked entry
    # that must be explicitly released by the calling entity
    # use a lock to ensure that if state is accessed by multiple threads
    # they do not attempt to access the locked entity simultaneously
    alias_method :old_state, :state
    def state
      result = nil
      @state_mutex.synchronize do
        result = old_state
      end
      result
    end
  end
end

module VagrantPlugins
  module Ansible
    class Config

      attr_accessor :inventory_retries

      alias_method :old_initialize, :initialize
      def initialize
        @inventory_retries   = UNSET_VALUE
        old_initialize
      end

      alias_method :old_finalize!, :finalize!
      def finalize!
        old_finalize!
        @inventory_retries   = 5 if @inventory_retries == UNSET_VALUE
      end

      alias_method :old_validate, :validate
      def validate(machine)
        errors = old_validate(machine)["ansible provisioner"]
        if inventory_retries.to_s != inventory_retries.to_i.to_s
          errors << ("`inventory_retries` for the Ansible proviersioner must " <<
            "be an integer. Received: #{inventory_retries.to_s} (as " <<
            "#{inventory_retries.class.to_s})")
        end
        { "ansible provisioner" => errors }
      end
    end

    class Provisioner
      include Vagrant::Util::Retryable

      # Add class lock here to line up with inclusion of Vagrant 1.7.4 changes
      # below in setup_inventory_file.
      @@lock = Mutex.new

      # override the default inventory file generation to isolate on a per machine
      # basis each instance of the inventory generated. Removes the need for locking
      # and ensures that the file will not be truncated or removed while ansible
      # is looking to read it.
      def setup_inventory_file
        return config.inventory_path if config.inventory_path

        # Managed machines
        inventory_machines = {}

        generated_inventory_dir = @machine.env.local_data_path.join(
          File.join(%w(provisioners ansible inventory)))
        FileUtils.mkdir_p(generated_inventory_dir) unless File.directory?(generated_inventory_dir)
        # generate a separate inventory file per machine to avoid race conditions
        generated_inventory_file = generated_inventory_dir.join(
          "#{machine.name}_vagrant_ansible_inventory")

        inventory = "# Generated by Vagrant\n\n"

        @machine.env.active_machines.each do |am|
          begin
            m = @machine.env.machine(*am)
            retryable(on: Vagrant::Errors::SSHNotReady,
                      tries: config.inventory_retries.to_i, sleep: 2) do
              m_ssh_info = m.ssh_info
              if !m_ssh_info.nil?
                inventory += "#{m.name} ansible_ssh_host=#{m_ssh_info[:host]} " <<
                  "ansible_ssh_port=#{m_ssh_info[:port]} " <<
                  "ansible_ssh_private_key_file=#{m_ssh_info[:private_key_path][0]}\n"
                inventory_machines[m.name] = m
              else
                # there may be more valid states to retry on, but not for libvirt
                if [:preparing, :running].include?(m.state.id)
                  @logger.info("Machine '#{am[0]} (#{am[1]})' not yet responding to ssh.")
                  raise Vagrant::Errors::SSHNotReady
                else
                  @logger.info("Machine '#{am[0]} (#{am[1]})' not running, ignoring.")
                  inventory += "# NOT RUNNING: ignoring non-running machine '#{m.name}'.\n"
                end
              end
            end
          rescue Vagrant::Errors::SSHNotReady => e
            @logger.error("Auto-generated inventory: Impossible to get SSH information for " <<
              "machine '#{m.name} (#{m.provider_name})'. This machine should be recreated.")
            # Leave a note about this missing machine in the inventory
            inventory += "# MISSING: '#{m.name}' machine was probably removed without using " <<
              "Vagrant. This machine should be recreated.\n"
          rescue Vagrant::Errors::MachineNotFound => e
            @logger.info("Auto-generated inventory: Skip machine '#{am[0]} (#{am[1]})', " <<
              "which is not configured for this Vagrant environment.")
          end
        end

        # Write out groups information.
        # All defined groups will be included, but only supported
        # machines and defined child groups will be included.
        # Group variables are intentionally skipped.
        groups_of_groups = {}
        defined_groups = []

        config.groups.each_pair do |gname, gmembers|
          # Require that gmembers be an array
          # (easier to be tolerant and avoid error management of few value)
          gmembers = [gmembers] if !gmembers.is_a?(Array)

          if gname.end_with?(":children")
            groups_of_groups[gname] = gmembers
            defined_groups << gname.sub(/:children$/, '')
          elsif !gname.include?(':vars')
            defined_groups << gname
            inventory += "\n[#{gname}]\n"
            gmembers.each do |gm|
              inventory += "#{gm}\n" if inventory_machines.include?(gm.to_sym)
            end
          end
        end

        defined_groups.uniq!
        groups_of_groups.each_pair do |gname, gmembers|
          inventory += "\n[#{gname}]\n"
          gmembers.each do |gm|
            inventory += "#{gm}\n" if defined_groups.include?(gm)
          end
        end

        # Vagrant 1.7.4 uses class lock to synchronise inventory
        # file I/O operations
        @@lock.synchronize do
          if ! File.exists?(generated_inventory_file) or
             inventory != File.read(generated_inventory_file)

            generated_inventory_file.open('w') do |file|
              file.write(inventory)
            end
          end
        end

        return generated_inventory_file.to_s
      end
    end
  end
end
